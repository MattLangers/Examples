name: IaC

on:
  workflow_call:
    inputs:
      artifactNameAPI:
        required: true
        type: string
      artifactNameSql:
        required: true
        type: string
      artifactNameTerraform:
        required: true
        type: string
      environment:
        required: true
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true
      AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_USERNAME:
        required: true
      AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_PASSWORD:
        required: true
      AZURE_SQL_INSTANCE_NAME:
        required: true
      AZURE_SQL_DATABASE_PRODUCTCATALOGUE_CONNECTION_STRING:
        required: true

jobs:
  infrastructure_create:
    permissions:
      id-token: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - uses: actions/download-artifact@v3
        with:
          path: artifacts
          
      - name: build static website
        working-directory: ./UI
        run: |
          npm install
          echo >> .env.production
          echo VITE_PRODUCT_CATALOGUE_API_URL="https://mrmclangley${{ inputs.environment }}productcatalogue.web.core.windows.net" >> .env.production
          npm run build
          
      - name: zip artifact
        working-directory: "./UI/.svelte-kit/output"
        run: | 
          zip -r ui.zip .

      - name: 'Az CLI login'
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2.0.0
        with:
          terraform_wrapper: false

      - name: Terraform Init Main
        id: init
        working-directory: "./artifacts/${{inputs.artifactNameTerraform}}"
        run: terraform init
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true

      - name: Terraform Plan Main
        id: plan
        working-directory: "./artifacts/${{ inputs.artifactNameTerraform }}"
        run: terraform plan -out main.tfplan -no-color -var sql_instance_administrator_login_username="${{ secrets.AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_USERNAME }}" -var sql_instance_administrator_login_password="${{ secrets.AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_PASSWORD }}" -var environment_prefix="${{ inputs.environment }}" -var sql_instance_name="${{ secrets.AZURE_SQL_INSTANCE_NAME }}"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true

      - name: Terraform Apply Main
        id: apply
        working-directory: "./artifacts/${{inputs.artifactNameTerraform}}"
        run: |
          terraform apply main.tfplan

          resource_group_name=$(terraform output resource_group_name)
          echo "::set-output name=resource_group_name::$resource_group_name"

          app_name=$(terraform output app_name)
          echo "::set-output name=app_name::$app_name"

          sql_instance_name=$(terraform output sql_instance_name)
          echo "::set-output name=sql_instance_name::$sql_instance_name"

          sql_database_name=$(terraform output sql_database_name)
          echo "::set-output name=sql_database_name::$sql_database_name"
        
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true

      - name: Init Terraform Firewall rules
        working-directory: "./artifacts/${{inputs.artifactNameTerraform}}/firewall-rules"
        run: terraform init
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true

      - name: Plan Terraform Firewall rules
        working-directory: "./artifacts/${{inputs.artifactNameTerraform}}/firewall-rules"
        run: terraform plan -out main.tfplan -no-color
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true

      - name: Apply Terraform Firewall rules
        working-directory: "./artifacts/${{inputs.artifactNameTerraform}}/firewall-rules"
        run: terraform apply main.tfplan
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
      
      ## A B1 webapp doesn't have slots so I don't think its possible to deploy to a B1 webapp using azure/webapps-deploy@v2
      - name: Deploy web app source code
        working-directory: "./artifacts/${{inputs.artifactNameAPI}}"
        run: | 
          az webapp deployment source config-zip -g ${{ steps.apply.outputs.resource_group_name }} -n ${{ steps.apply.outputs.app_name }} --src api.zip
      
      - name: Acquire connection strings
        id: setSqlConnection
        run: |
          $raw_connection_string = $(az sql db show-connection-string -s ${{ steps.apply.outputs.sql_instance_name }} -n ${{ steps.apply.outputs.sql_database_name }} -c ado.net)
          
          $connection_string_tcp = $raw_connection_string.Replace("<password>", "${{ secrets.AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_PASSWORD }}")
          $connection_string_tcp = $connection_string_tcp.Replace("<username>", "${{ secrets.AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_USERNAME }}")
          Write-Output "::set-output name=connection_string_tcp::'$($connection_string_tcp)'"
          
          $manual_connection_string = $raw_connection_string.Replace("<password>", "${{ secrets.AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_PASSWORD }}")
          $manual_connection_string = $manual_connection_string.Replace("<username>", "${{ secrets.AZURE_SQL_INSTANCE_ADMINISTRATOR_LOGIN_USERNAME }}")
          $manual_connection_string = $manual_connection_string.Replace("Server=tcp:", "Server=")
          $manual_connection_string = $manual_connection_string.Replace(",1433", "")
          
          Write-Output "::set-output name=manual_connection_string::'$($manual_connection_string)'"
        shell: pwsh

      - name: Setup connection string for webapp
        run: | 
          az webapp config connection-string set -g ${{ steps.apply.outputs.resource_group_name }} -n ${{ steps.apply.outputs.app_name }} -t SQLAzure \
          --settings ProductCatalogue='${{ steps.setSqlConnection.outputs.connection_string_tcp }}'
    
      - name: Azure SQL Deploy
        uses: azure/sql-action@v1.3
        with:
          connection-string: ${{ secrets.AZURE_SQL_DATABASE_PRODUCTCATALOGUE_CONNECTION_STRING }}
          sql-file: "./artifacts/${{inputs.artifactNameSql}}/product-catalogue-migration-script.sql"
  
      - name: 'Logout az'
        run: az logout